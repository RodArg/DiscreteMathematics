<html>
    <head>
        <link href="style.css" rel="stylesheet" type="text/css"/>
        <title>
            Algorithms
        </title>
    </head>

    <body>

    <div id="header">
        <div id="logo">
            <img
            src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/5b/6n-graf.svg/250px-6n-graf.svg.png"
            height="56" width="84"
            max-height=100%>
        </div>
        <div id="user-tools">
            <a href="index.html">Home</a>
            &nbsp; &nbsp; 
            <a href="about.html">About</a>
        </div>
    </div>


        <h1 class="chap-title">
            Algorithms
        </h1>
            <div style="text-align:center">
                <figure class="lead-figure">
                    <img
                        src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/6a/Sorting_quicksort_anim.gif/220px-Sorting_quicksort_anim.gif">
                </figure>
            </div>


            <details>
                <summary class="sum1">
                Algorithms 
                </summary>
            		<p>
                	An <b>algorithm</b> is a finite sequence of precise instructions 
                	for performing a computation or for solving a problem.
                	</p>
                	<p>
                	Algorithm for finding the maximum (largest) value in a finite 
                	sequence of integers:
                	Solution Steps:
                	</p>
                	<ol>
                      	<li>
                        	Set the temporary maximum equal to the first integer in 
                    		the sequence.
                    	</li>
                    	<li>
                    		Compare the next integer in the sequence to the temporary 
                    		maximum, and if it is larger than the temporary maximum, set the 
                    		temporary maximum equal to this integer.
                    	</li>
                    	<li>
                      		Repeat the previous step if there are more integers in the
                    		sequence.
                  	</li>
                  	<li>
                        	Stop when there are no integers left in the sequence. 
                        	The temporary maximum at this point is the largest integer in 
                        	the sequence.
                        </li>
                    </ol>
                    <p>
            		Properties of an Algorithm
            		</p>
                	<ol>
                    	<li>
                    		Input
                    	</li>
                    	<li>
                    		Output
                    	</li>
                    	<li>
                    		Definitiveness
                    	</li>
                    	<li>
                    		Correctness
                    	</li>
                    	<li>
                    		Finiteness
                    	</li>
                    	<li>
                    		Effectiveness
                    	</li>
                    	<li>
                    		Generality
                    	</li>
                    </ol>
                	<details>
                		<summary class="sum2">
                		Searching Algorithm 
                		</summary>
                			<p>
                			The problem of locating an element in an ordered list occurs in 
                			many contexts. For instance, a program that checks the spelling of 
                			words searches for them in a dictionary, which is just an ordered 
                			list of words. Problems of this kind are called searching problems.
                			</p>
                			<details>
                				<summary class="sum3">
                				Linear Search
                				</summary>
                					<p>
                					&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
                					<img src="https://www.tutorialspoint.com/data_structures_algorithms/images/linear_search.gif" 
                					alt="Linear Search Animation">
                					<br>
                					<p><b>procedure</b> <i>linear search(x</i>: integer, <i>a1, a2, .
                			 		. . , an</i>: distinct integers)<br>
                					<i>i := 1</i><br>
                					<b>while</b> (i <= n and x != a[i] )<br>
                					&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
                					i = i + 1
                					<br>
                					<b>if</b> i <= n <b>then</b> <i>location</i> := i<br>
                					<b>else</b> <i>location =</i> 0
                					<br>
                					<b>return</b> <i>location{location</i> is the subscript of 
							the term that equals <i>x</i>, or is 0 if <i>x</i> is not found}
							</p>
                			</details>
                			<details>
                				<summary class="sum3">
                				Binary Search
                				</summary>
                					<p>
                					This algorithm can be used when the list has terms occurring in 
                					order of increasing size (for instance: if the terms are numbers, 
                					they are listed from smallest to largest; if they are words, they 
                					are listed in lexicographic, or alphabetic, order). This second 
                					searching algorithm is called the binary search algorithm.
                					<br>
                					&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
                					<img 
                					src = "https://www.tutorialspoint.com/data_structures_algorithms/images/binary_search_0.jpg">
                					<br>
                					&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
                					<img 
                					src = "https://www.tutorialspoint.com/data_structures_algorithms/images/binary_search_1.jpg">
                					<br>
                					&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
                					<img
                					src = "https://www.tutorialspoint.com/data_structures_algorithms/images/binary_search_2.jpg">
                					<br>
                					&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
                					<img 
                					src = "https://www.tutorialspoint.com/data_structures_algorithms/images/binary_search_3.jpg">
                					<br>
                					&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
                					<img
                					src = "https://www.tutorialspoint.com/data_structures_algorithms/images/binary_search_4.jpg">
                					<br>
                					&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
                					<img
                					src = "https://www.tutorialspoint.com/data_structures_algorithms/images/binary_search_5.jpg">
                					<br>
                					&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
                					<img
                					src = "https://www.tutorialspoint.com/data_structures_algorithms/images/binary_search_6.jpg">
                					<br>
                					&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
                					</p>
                			</details>
                	</details>
                	<details>
                	<summary class="sum2">
                	Sorting Algorithms
                	</summary>
                		<details>
                			<summary class="sum3">
                			Bubble Sort
                			</summary>
                				<p>
                				&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
                				<img src="http://www.opentechguides.com/images/howto/howto_5101.png">
                				<br>
                				<b>Psuedocode</b>
                				<br>
                				&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
                				<img src="graphics/BubbleSort.svg.png">
                				<br>
                				</p>
                		</details>
                		<details>
                			<summary class="sum3">
                			Insertion Sort
                			</summary>
                				<p>
                				&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
                				<img src="https://www.tutorialspoint.com/data_structures_algorithms/images/unsorted_array.jpg">
                				<br>
                				&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
                				<img src="https://www.tutorialspoint.com/data_structures_algorithms/images/insertion_sort_1.jpg">
                				<br>
                				&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
                				<img src="https://www.tutorialspoint.com/data_structures_algorithms/images/insertion_sort_2.jpg">
                				<br>
                				&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
                				<img src="https://www.tutorialspoint.com/data_structures_algorithms/images/insertion_sort_3.jpg">
                				<br>
                				&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
                				<img src="https://www.tutorialspoint.com/data_structures_algorithms/images/insertion_sort_4.jpg">
                				<br>
                				&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
                				<img src="https://www.tutorialspoint.com/data_structures_algorithms/images/insertion_sort_5.jpg">
                				<br>
                				&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
                				<img src="https://www.tutorialspoint.com/data_structures_algorithms/images/insertion_sort_6.jpg">
                				<br>
                				&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
                				<img src="https://www.tutorialspoint.com/data_structures_algorithms/images/insertion_sort_7.jpg">
                				<br>
                				&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
                				<img src="https://www.tutorialspoint.com/data_structures_algorithms/images/insertion_sort_8.jpg">
                				<br>
                				&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
                				<img src="https://www.tutorialspoint.com/data_structures_algorithms/images/insertion_sort_9.jpg">
                				<br>
                				&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
                				<img src="https://www.tutorialspoint.com/data_structures_algorithms/images/insertion_sort_10.jpg">
                				<br>
                				&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
                				<img src="https://www.tutorialspoint.com/data_structures_algorithms/images/insertion_sort_11.jpg">
                				<br>
                				&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
                				<img src="https://www.tutorialspoint.com/data_structures_algorithms/images/insertion_sort_12.jpg">
                				<br>
                				<b>Psuedocode</b>
                				<br>
                				&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
                				<img src="graphics/InsertionSort.svg.png">
                				<br>
                				</p>
                		</details>
                	</details>
                	<details>
                		<summary class="sum2">
                		Greedy Algorithms
                		</summary>
                		<p>
                		Algorithms that make what seems to be the best
				choice at each step are called <b>greedy algorithms.</b>
				<br>
                		<b>Greedy Change-Making Algorithm</b>
                		<br>
                		&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
                		<img src="graphics/GreedyChangeMaking.svg.png">
                		<br>
                		</p>
                		<p class="def">LEMMA 1</p>
               			<p>
               			If n is a positive integer, then n cents in change using 
               			quarters, dimes, nickels, and pennies using the fewest coins possible 
               			has at most two dimes, at most one nickel, at most four pennies, and 
               			cannot have two dimes and a nickel. The amount of change in dimes, 
               			nickels, and pennies cannot exceed 24 cents.
               			</p>
               			<br>
               			<p class="def">THEOREM 1</p>
               			<p>
               			The greedy algorithm produces change using the 
               			fewest coins possible.<br>
               			<br>
               			<b>Greedy Algorithm for Scheduling Talks</b>
               			<br>
               			&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
                		<img src="graphics/GreedyScheduling.svg.png">
                		<br>
                		</p>
                	</details>
                	<details>
                	<summary class="sum2">
                	The Halting Problem
                	</summary>
                		<p>
                		<b>The Halting Problem is Unsolvable</b><br>
                		<br>
                		&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
                		<img src="graphics/HaltingProblem.svg.png">
                		<br>
                		</p>
                	</details>    	
		</details>
		<details>
            	<summary class="sum1">
                The Growth of Functions 
                </summary>
                	<details>
                		<summary class="sum2">
                		Big-O Notation
                		</summary>
                		<p class="def">DEFINITION 1</p>
                		<p>Let <i>f</i> and <i>g</i> be functions from the set of integers 
                		or the set of real numbers to the set of real numbers.We say that 
                		<i>f(x)</i> is <i>O(g(x))</i> if there are constants <i>C</i> and 
                		<i>k</i> such that |<i>f(x)</i>| &le; <i>C</i>|<i>g(x)</i>|whenever 
                		<i>x</i> > <i>k</i>.
                		<br> 
                 		(This is read as "<i>f(x)</i> is big-oh of <i>g(x)</i>.")
                 		<br>
				<b>Example 1 </b>Show that <i>f(x)</i> = 7<i>x<sup>2</sup></i> is 
				O(<i>x<sup>3</sup></i>).
				Take <i>C</i> =1 and <i>k</i> = 7 as witnesses to establish 
				that 7<i>x<sup>2</sup></i>  is <i>O(x<sup>3</sup>)</i>.
				<br>
				When <i>x</i> > 7, 7<i>x<sup>2</sup></i> < <i>x<sup>3</sup></i>.
				<br>
				Consequently, we can take <i>C</i>= 1 and <i>k</i> = 7 as 
				witnesses to establish the relationship 7<i>x<sup>2</sup></i> is 
				O(<i>x<sup>3</sup></i>).
				<br>
				Alternatively, when <i>x</i> > 1, we have 7<i>x<sup>2</sup></i> < 
				7<i>x<sup>3</sup></i>, so that <i>C</i> = 7 
				and <i>k</i> = 1 are also witnesses to the relationship 
				7<i>x<sup>2</sup></i> is <i>O(x<sup>3</sup>)</i>.
				</p>
                	</details>
            		<details>
                		<summary class="sum2">
                		Big-O Estimates for Some Important Functions
                		</summary>
                		<p class="def">THEOREM 1</p>
                		<p>Let <i>f(x)</i> = a<sub>n</sub>x<sup>n</sup> +
                		a<sub>n-1</sub>x<sup>n-1</sup> +...+ ax + a, where a<sub>0</sub>, 
                		a<sub>1</sub>...
                		a<sub>n - 1</sub>, a<sub>n</sub> are real numbers.
                		<br>
				Then f(x) is O(x<sup>n</sup>).
				<br>
				<b>A Display of the Growth of Functions Commonly Used in Big-O 
				Estimates.</b>
				<br>
				&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
				<img src="graphics/BigOEstimates.svg.png">
				</p>
                	</details>
                	<details>
                		<summary class="sum2">
                		The Growth of Combinations of Functions
                		</summary>
                		<p class="def">THEOREM 2</p>
                		<p>Suppose that <i>f<sub>1</sub> (x)</i> is 
                		<i>O(g<sub>1</sub> (x))</i> and that 
                		<i>f<sub>2</sub> (x)</i> is <i>O(g<sub>2</sub> (x))</i>.<br> 
                		Then <i>(f<sub>1</sub>  + f<sub>2</sub> )(x)</i> is <i>O</i>
                		(max(|<i>g<sub>1</sub> 
                		(x)</i>|, |<i>g<sub>2</sub> (x)</i>|)).
                		</p>
                		<p class="def">COROLLARY 1</p>
                		<p>Suppose that <i>f<sub>1</sub>(x)</i> and <i>f<sub>2</sub>(x)</i> 
                		are both <i>O(g(x))</i>.<br>
                		Then (<i>f<sub>1</sub></i> + <i>f<sub>2</sub>)(x)</i> is 
                		<i>O(g(x))</i>.
                		</p>
                 		<p class="def">THEOREM 3</p>
                		<p>Suppose that <i>f<sub>1</sub>(x)</i> is <i>O(g<sub>1</sub>(x))</i> 
                		and <i>f<sub>2</sub>(x)</i> is <i>O(g<sub>2</sub>(x)</i>).
                		<br>
                		Then <i>(f<sub>1</sub>f<sub>2</sub>)(x)</i> is 
                		<i>O(g<sub>1</sub>(x)g<sub>2</sub>(x))</i>.
                		</p>
			</details>
                
                	<details>
                		<summary class="sum2">
                		Big-Omega and Big-Theta Notation
                		</summary>
        			<p class="def">DEFINITION 2</p>
        			<p>
        			Let <i>f</i> and <i>g</i> be functions from the set of integers 
        			or the set of real numbers to the set of real numbers.We say that 
       				<i>f (x)</i> is <i>&#937;(g(x))</i> if there are positive constants 
       				<i>C</i> and <i>k</i> such that |<i>f (x)</i>| &ge; 
       				<i>C</i>|<i>g(x)</i>| whenever <i>x</i> > <i>k</i>.
       				<br>
       				(This is read as "f (x) is big-Omega of g(x).")
       				<br>
       				<b>Example : </b>Show that <i>f(x)</i> = <i>x<sup>3</sup></i> is 
				&Omega;(7<i>x<sup>2</sup></i>).
				<ul>
					<li>
						In the above example we have proved the exact opposite.
				    	</li>
				    	<li>
				    		Consider the same witness <i>C</i> =1 and <i>k</i> = 7 to 
				    		establish this relation
				    	</li>
					<li>
				    		Just by turning in inequality, we can sat that f(x) is &Omega;
				    		(7<i>x<sup>2</sup></i>)
				    	</li>
			    	</ul>
        			</p>
        			<p class="def">DEFINITION 3</p>
  				<p>      		
        			Let <i>f</i> and <i>g</i> be functions from the set of integers 
       				or the set of real numbers to the set of real numbers.We say that
       				<i>f (x)</i> is <i>&#920;(g(x))</i> if <i>f(x)</i> is <i>O(g(x))</i> 
       				and <i>f(x) </i>is <i>&#937;(g(x))</i>. When <i>f(x)</i> is 
       				<i>&#920;(g(x))</i> we say that <i>f</i> is big-Theta of <i>g(x)</i>, 
       				that <i>f(x)</i> is of order <i>g(x)</i>, and that <i>f(x)</i> and 
       				<i>g(x)</i> are of the same order.
       				<br>
       				<b>Example :</b> Show that 3<i>x<sup>2</sup></i> + 8<i>x</i> 
        			log <i>x</i> is <i>&Theta;(x<sup>2</sup>)</i>.
        			<br>
        			<ul>
        				<li>
        					Because 0 &le; 8<i>x</i> log <i>x</i> &le; 8<i>x<sup>2</sup></i>, 
        					it follows that 3<i>x<sup>2</sup></i> + 8<i>x</i> log <i>x</i> 
        					&le; 11<i>x<sup>2</sup></i> for <i>x</i> > 1.
        				</li>
        				<li>
       						Consequently, 3<i>x<sup>2</sup></i> + 8<i>x</i> log <i>x</i> is 
       						O(<i>x<sup>2</sup></i>). 
       					</li>
					<li>
						Clearly, <i>x<sup>2</sup></i> is 
						O(3<i>x<sup>2</sup></i> + 8<i>x</i> log <i>x</i>).
					</li>
					<li>
						Consequently, 3<i>x<sup>2</sup></i> + 8<i>x</i> log <i>x</i> is 
						<i>&Theta;(x<sup>2</sup>)</i>.
					</li>
				</ul>
        			</p>
        			<p class="def">THEOREM 4</p>
        			<p>Let <i>f(x)</i> = <i>a<sub>n</sub>x<sup>n</sup></i> + 
        			 <i>a<sub>n-1</sub>x<sup>n-1</sup></i> +...+ <i>a<sub>1</sub>x</i>  
       				 + <i>a<sub>0</sub></i>, where <i>a<sub>0</sub></i>, 
       				 <i>a<sub>1</sub></i>, . . . , an are real numbers 
       				 with <i>a<sub>n</sub> &ne;</i> 0.
       				 <br>
       				 Then <i>f(x)</i> is of order <i>x<sup>n</sup></i>.</p>
                </details>  
            </details>
            <details>
                <summary class="sum1">
                Complexity of Algorithms 
                </summary>
                <details>
                <summary class="sum2">
                Time Complexity
                </summary>
                <p>An analysis of the time required to solve a problem of a particular 
                size involves the time complexity of the algorithm.The time complexity of 
                an algorithm can be expressed in terms of the number of operations 
                used by the algorithm when the input has a particular size.
                <br>
                In most of the cases we consider the worst-case time complexity of an 
                algorithm. This provides an upper bound on the number of operations an 
                algorithm uses to solve a problem with input of a particular size.
                <br>
                <b>Complexity Analysis of Some Algorithms</b>
                <br>
                <b>Example :</b> Describe the time complexity of an Algorithm for finding 
                the maximum element in a finite set of integers.
                <ul>
                	<li>
                		Count the number of comparisons
                	</li>
                	<li>
                		There are n comparisons  while entering the for loop, one extra when i
                		becomes equal to n
                	</li>
                	<li>
                		There are n-1 comparison in the if loop to check the maximum element
                	</li>
                	<li>
                		The total comparison will be n + (n-1)<br>
                		2(n-1) - 1 = 2n -1 comparisons are made
                	</li>
			<li>
                		Hence, the complexity will be &Theta;(n)
			</li>
                </ul>       
                </p>
                </details>
                <details>
                	<summary class="sum2">
               		 Complexity of Matrix Multiplication
                	</summary>
                	<p>The definition of the product of two matrices can be expressed as an
                 	algorithm for computing the product of two matrices. Suppose that 
                 	<b>C</b> = [<i>c<sub>ij</sub></i>] is the <i>m &#x2715; n</i> matrix that is the 
                 	product of the <i>m &#x2715; k</i> matrix <b>A</b> = [<i>a<sub>ij</sub></i>] 
                 	and the k &#x2715; n matrix <b>B</b> = [<i>b<sub>ij</sub></i> ].
                 	<br>
                 	<b>Pseudocode Matrix Multiplication</b>
                 	<br>
                 	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
                 	<img src="graphics/MatrixMultiplication.svg.png">
                 	<br>
                 	<b>Complexity Calculation</b>
                 	How many additions of integers and multiplications of integers are used 
                 	by the matrix multiplication algorithm to multiply two <i>n * n </i>matrices.
                 	<ul>
                 		<li>
                 			There are a total of <i>n<sup>2</sup></i> elements in the product matrix.
                 		</li>
                 		<li>
                 			Each element requires <i>n</i> multiplications and <i>n-1</i> additions.
                 		</li>
                 		<li>
                 			Hence, <i>n<sup>3</sup></i> multiplications and
                 			<i>n<sup>2</sup>(n - 1)</i> additions are used.
                 		</li>
                 		<li>
                 			Hence, the complexity of matrix multiplication is <i>O(n<sup>3</sup>)</i>.  
                 		</li>
                	</ul>
                </p>
                </details>
                <details>
                <summary class="sum2">
                Algorithmic Paradigms
                </summary>
                <p>
                Algorithm Paradigms is a general approach based on a particular concept 
                that can be used to construct algorithms for solving a variety of problems.
                Greedy Algorithm, Divide and Conquer Algorithm, 
                Brute Force Algorithm, Probabilistic Algorithm are algorithm paradigms.
                <br>
                <br>
                <b>Example :</b> 
                Brute Force Algorithms
		<br>
		A brute-force algorithm is solved in the most straightforward manner, 
		without taking advantage of any ideas that can make the algorithm more 
		efficient.
                Construct a brute-force algorithm for finding the closest pair of 
                points in a set of n points in the plane and provide a worst-case 
                estimate of the number of arithmetic operations.
                <br>
                <br>
		<b>Pseudocode for Brute-Force Closest Point Algorithm</b>
                <br>
                &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
                <img src="graphics/ClosestPairAlgorithm.svg.png">
                <br>
                <br>
                <b>Complexity of the Algorithm</b>
                <br>
                The algorithm loops through <i>n(n - 1)/2</i> pairs of points, computes the value    
                (<i>x<sub>j</sub></i> - <i>x<sub>i</sub>)<sup>2</sup></i> + 
                (<i>y<sub>j</sub></i> - <i>y<sub>i</sub>)<sup>2</sup></i> and 
                compares it with the minimum, etc. So, the algorithm uses
                <i> &Theta;(n<sup>2</sup>)</i> 
                arithmetic and comparison operations.
                </p>
                </details>
                <details>
                <summary class="sum2">
                Understanding the Complexity of Algorithms
                </summary>
                <p>
                <table>
                    <tr>
                        <th class="table-head" colspan="2">
                            Commonly Used Terminology for the Complexity of Algorithms.
                        </th>
                    </tr>
                    <tr>
                        <th>
                            Complexity
                        </th>
                        <th>
                            Terminology
                        </th>
                    </tr>
                    <tr>
                        <td>
                            &Theta;(1)
                        </td>
                        <td>
                            Constant Complexity
                        </td>
                    </tr>
                    <tr>
                        <td>
                            &Theta;(log <i>n</i>)
                        </td>
                        <td>
                            Logarithmic Complexity
                        </td>
                    </tr>
                    <tr>
                        <td>
                            &Theta;(<i>n</i>)
                        </td>
                        <td>
                            Linear Complexity
                        </td>
                    </tr>
                    <tr>
                        <td>
                            &Theta;(<i>n</i> log <i>n</i>)
                        </td>
                        <td>
                            Linearithmic complexity
                        </td>
                    </tr>
                    <tr>
                        <td>
                            &Theta;(<i>n<sup>b</sup></i>)
                        </td>
                        <td>
                            Polynomial complexity
                        </td>
                    </tr>
                    <tr>
                        <td>
                            &Theta;(<i>b<sup>n</sup></i>) where <i>b</i> >1
                        </td>
                        <td>
                            Exponential Complexity
                        </td>
                    </tr>
                    <tr>
                        <td>
                            &Theta;(<i>n!</i>)
                        </td>
                        <td>
                            Factorial Complexity
                        </td>
                    </tr>
                </table>
                <br>
                <b>Tractable problem : </b>a problem for which there is a worst-case 
                polynomial-time algorithm that solves it
		<br>
		<b>Intractable problem : </b>a problem for which no worst-case
		polynomial-time algorithm exists for solving it
		<br>
		<b>Solvable problem : </b>a problem that can be solved by an algorithm
		<br>
		<b>unsolvable problem : </b>a problem that cannot be solved by an
		algorithm
                </p>
                </details>
            </details>
    </body>
</html>	


